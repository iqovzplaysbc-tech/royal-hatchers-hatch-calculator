<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Royal Hatchers Luck Calculator</title>
  <style>
    body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#0f0f14;color:#eaeaea;padding:18px;}
    .wrap{max-width:900px;margin:0 auto;}
    h1{font-size:20px;margin:0 0 12px 0;}
    .card{background:#171722;border:1px solid #2a2a3a;border-radius:10px;padding:12px;margin:12px 0;}
    .row{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px;}
    .row2{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;}
    @media(max-width:820px){.row{grid-template-columns:repeat(2,minmax(0,1fr));}}
    label{font-size:12px;color:#bdbdd1;display:block;margin-bottom:4px;}
    input,select{width:100%;box-sizing:border-box;padding:8px;border-radius:8px;border:1px solid #2a2a3a;background:#0f0f14;color:#eaeaea;}
    button{padding:9px 12px;border-radius:9px;border:0;cursor:pointer;background:#2c6cff;color:#fff;font-weight:bold;}
    button:disabled{opacity:.5;cursor:not-allowed;}
    .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;}
    .tab{background:#232336;border:1px solid #2a2a3a;color:#eaeaea;padding:8px 10px;border-radius:999px;cursor:pointer;font-size:13px;}
    .tab.active{background:#2c6cff;border-color:#2c6cff;}
    .muted{color:#bdbdd1;font-size:12px;}
    pre{white-space:pre-wrap;background:#0b0b10;border:1px solid #2a2a3a;border-radius:10px;padding:10px;margin:10px 0 0 0;}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #2a2a3a;background:#0f0f14;margin-left:6px;color:#bdbdd1}
    .tier{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #2a2a3a;background:#0f0f14;color:#bdbdd1}
    .tier.Royal{border-color:#7d3cff;color:#cbb7ff}
    .tier.Secret{border-color:#ff4d7a;color:#ffb3c7}
    .tier.Legendary{border-color:#f7c942;color:#ffe7a0}
    .tier.Epic{border-color:#7ad7ff;color:#bfeeff}
    .tier.Rare{border-color:#72ff98;color:#bfffd0}
  </style>
</head>
<body>
<div class="wrap">
  <h1>Royal Hatchers Hatch Calculator <span class="pill">v1.2</span></h1>
  <div class="muted">Tip: Use your in-game Debug values for the most accurate results (Luck %, Hatch Time, Egg Hatches).</div>

  <!-- STATS -->
  <div class="card">
    <div class="row">
      <div>
        <label>Luck % (Debug) üçÄ</label>
        <input id="luckPercent" type="number" value="0" min="0" step="1" placeholder="Example: 1678" />
        <div class="muted" id="luckMulText"></div>
      </div>
      <div>
        <label>Hatch Time (seconds) (Debug) ‚è±Ô∏è</label>
        <input id="hatchTimeSec" type="number" value="1" min="0.01" step="0.01" placeholder="Example: 0.9" />
      </div>
      <div>
        <label>Egg Hatches per Batch (Debug) ü•ö</label>
        <input id="eggsPerCycle" type="number" value="1" min="1" step="1" placeholder="Example: 10" />
      </div>
      <div>
        <label>Shiny Multiplier ‚ú®</label>
        <input id="shinyMult" type="number" value="100" min="1" step="1" />
      </div>
    </div>
  </div>

  <!-- TABS -->
  <div class="tabs">
    <div class="tab active" data-tab="single">Single Pet</div>
    <div class="tab" data-tab="eggs">Egg Odds</div>
    <div class="tab" data-tab="sim">Simulator</div>
  </div>

  <!-- SINGLE -->
  <div class="card" id="single">
    <div class="row2">
      <div>
        <label>Pick a pet (from any egg)</label>
        <select id="singlePetSelect"></select>
        <div class="muted" id="singlePetMeta"></div>
      </div>
      <div>
        <label>Or enter Base Odds (1/x or %)</label>
        <input id="baseOddsInput" placeholder='Examples: 1/3000000  |  0.01%  |  3.69%' />
        <div class="muted">If you type here, it overrides the dropdown‚Äôs odds.</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>Also compute shiny?</label>
        <select id="wantShiny">
          <option value="no">No</option>
          <option value="yes">Yes (same pet, shiny)</option>
        </select>
      </div>
      <div style="display:flex;align-items:end;gap:8px;">
        <button id="calcSingleBtn">Calculate</button>
        <button id="copySingleBtn">Copy</button>
      </div>
    </div>

    <pre id="singleOut">Pick a pet (or enter odds), then Calculate.</pre>
  </div>

  <!-- EGGS -->
  <div class="card" id="eggs" style="display:none;">
    <div class="row2">
      <div>
        <label>Egg</label>
        <select id="eggSelect"></select>
        <div class="muted" id="eggMeta"></div>
      </div>
      <div>
        <label>Filter tier</label>
        <select id="tierFilter">
          <option value="Legendary+">Legendary+</option>
          <option value="">All</option>
          <option value="Epic+">Epic+</option>
          <option value="Legendary">Legendary only</option>
          <option value="Secret+">Secret+</option>
          <option value="Royal">Royal only</option>
          <option value="Secret">Secret only</option>
          <option value="Epic">Epic only</option>
          <option value="Rare">Rare only</option>
          <option value="Common">Common only</option>
        </select>
      </div>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="renderEggBtn">Show Egg Odds</button>
      <button id="copyEggBtn">Copy</button>
    </div>

    <pre id="eggOut">Select an egg, then ‚ÄúShow Egg Odds‚Äù.</pre>
  </div>

  <!-- SIM -->
  <div class="card" id="sim" style="display:none;">
    <div class="row">
      <div>
        <label>Egg</label>
        <select id="simEggSelect"></select>
      </div>
      <div>
        <label>Batches to simulate</label>
        <input id="simCycles" type="number" min="1" step="1" value="5000"/>
        <div class="muted">Each batch opens (Egg Hatches) eggs.</div>
      </div>
      <div>
        <label>Stop early if hit (optional)</label>
        <select id="simStopPet">
          <option value="">No early stop</option>
        </select>
      </div>
      <div>
        <label>Stop condition</label>
        <select id="simStopMode">
          <option value="any">Get at least 1</option>
          <option value="shiny">Get shiny (uses shiny multiplier)</option>
        </select>
      </div>
    </div>

    <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="simBtn">Run Simulation</button>
      <button id="copySimBtn">Copy</button>
    </div>

    <pre id="simOut">Simulator model:
‚Ä¢ Percent pets roll normally (like 70%, 25%, etc)
‚Ä¢ 1/x pets (Legendary/Secret/Royal) are independent rare checks per egg hatch
‚Ä¢ Secret Bounty has ‚ÄúNothing‚Äù most of the time, and Prisma Shard very rarely</pre>
  </div>

  <div class="muted" style="margin-top:14px;">
  </div>
</div>

<script>
(() => {
  // ========= Data =========
  const EGGS = [
    {
      name: "Common Egg",
      cost: 50,
      currency: "coins",
      enabled: true,
      pets: [
        { name: "Doggy", tier: "Common", type: "percent", value: 50 },
        { name: "Kitty", tier: "Common", type: "percent", value: 35 },
        { name: "Bunny", tier: "Rare", type: "percent", value: 15 },
        { name: "Bear", tier: "Epic", type: "percent", value: 4.9 },
        { name: "King Kitty", tier: "Royal", type: "odds", value: 19999999 }
      ]
    },
    {
      name: "Spotted Egg",
      cost: 300,
      currency: "coins",
      enabled: true,
      pets: [
        { name: "Mouse", tier: "Common", type: "percent", value: 55 },
        { name: "Deer", tier: "Common", type: "percent", value: 30 },
        { name: "Fox", tier: "Rare", type: "percent", value: 11 },
        { name: "Bee", tier: "Epic", type: "percent", value: 4 }
      ]
    },
    {
      name: "Rocky Egg",
      cost: 1000,
      currency: "coins",
      enabled: true,
      pets: [
        { name: "Rocky Doggy", tier: "Common", type: "percent", value: 30 },
        { name: "Rocky Kitty", tier: "Common", type: "percent", value: 25 },
        { name: "Rocky Fox", tier: "Rare", type: "percent", value: 20 },
        { name: "Rocky Dinosaur", tier: "Rare", type: "percent", value: 15 },
        { name: "Rocky Golem", tier: "Rare", type: "percent", value: 7 },
        { name: "Rocky Dragon", tier: "Epic", type: "percent", value: 3 }
      ]
    },
    {
      name: "Mushroom Egg",
      cost: 2500,
      currency: "coins",
      enabled: true,
      pets: [
        { name: "Mushroom Doggy", tier: "Common", type: "percent", value: 55 },
        { name: "Mushroom Kitty", tier: "Common", type: "percent", value: 30 },
        { name: "Mushroom Bunny", tier: "Rare", type: "percent", value: 11 },
        { name: "Mushroom Fox", tier: "Epic", type: "percent", value: 3.69 },
        { name: "Majestic Mushy", tier: "Legendary", type: "odds", value: 333 },
        { name: "King Mushy", tier: "Secret", type: "odds", value: 3000000 }
      ]
    },
    {
      name: "Leaf Egg",
      cost: 5000,
      currency: "coins",
      enabled: true,
      pets: [
        { name: "Leaf Doggy", tier: "Common", type: "percent", value: 55 },
        { name: "Leaf Kitty", tier: "Common", type: "percent", value: 30 },
        { name: "Leaf Bunny", tier: "Rare", type: "percent", value: 11 },
        { name: "Squirrel", tier: "Epic", type: "percent", value: 3.69 },
        { name: "Angelic Pumpkin", tier: "Legendary", type: "odds", value: 571 },
        { name: "Elegant Leaf", tier: "Secret", type: "odds", value: 3000000 }
      ]
    },
    {
      name: "Arctic Egg",
      cost: 12500,
      currency: "coins",
      enabled: true,
      pets: [
        { name: "Arctic Doggy", tier: "Common", type: "percent", value: 55 },
        { name: "Arctic Golem", tier: "Common", type: "percent", value: 30 },
        { name: "Arctic Bear", tier: "Rare", type: "percent", value: 11 },
        { name: "Arctic Dragon", tier: "Epic", type: "percent", value: 3.69 },
        { name: "Mammoth", tier: "Legendary", type: "odds", value: 500 },
        { name: "Yeti", tier: "Secret", type: "odds", value: 3000000 }
      ]
    },
    {
      name: "Icy Egg",
      cost: 20000,
      currency: "coins",
      enabled: true,
      pets: [
        { name: "Icy Bear", tier: "Common", type: "percent", value: 55 },
        { name: "Icy Fox", tier: "Common", type: "percent", value: 30 },
        { name: "Icy Deer", tier: "Rare", type: "percent", value: 11 },
        { name: "Icy Dinosaur", tier: "Epic", type: "percent", value: 3.69 },
        { name: "Icy Blast", tier: "Legendary", type: "odds", value: 2000 },
        { name: "Frost Overlord", tier: "Legendary", type: "odds", value: 20000 },
        { name: "Frost Fiend", tier: "Secret", type: "odds", value: 3500000 }
      ]
    },
    {
      name: "Lovely Egg",
      cost: 100,
      currency: "hearts",
      enabled: true,
      pets: [
        { name: "Lovely Doggy", tier: "Common", type: "percent", value: 50 },
        { name: "Lovely Kitty", tier: "Rare", type: "percent", value: 40 },
        { name: "Lovely Bunny", tier: "Epic", type: "percent", value: 10 },
        { name: "Lovestruck Dragon", tier: "Legendary", type: "odds", value: 400 },
        { name: "Lovestruck Star", tier: "Secret", type: "odds", value: 2000000 }
      ]
    },
    {
      name: "Valentines Egg",
      cost: 500,
      currency: "hearts",
      enabled: true,
      pets: [
        { name: "Valentines Mouse", tier: "Common", type: "percent", value: 70 },
        { name: "Valentines Fox", tier: "Rare", type: "percent", value: 25 },
        { name: "Winged Heart", tier: "Epic", type: "percent", value: 4 },
        { name: "Lovely Blast", tier: "Legendary", type: "odds", value: 1333 },
        { name: "Lovely Teddy Bear", tier: "Legendary", type: "odds", value: 20000 },
        { name: "Cupid", tier: "Legendary", type: "odds", value: 111111 },
        { name: "Heavenly Rose", tier: "Secret", type: "odds", value: 4999999 },
        { name: "Lovely Harp", tier: "Secret", type: "odds", value: 12500000 },
        { name: "Loyal Heart", tier: "Royal", type: "odds", value: 30000000 }
      ]
    },
    {
      name: "Secret Bounty",
      cost: 0,
      currency: "special",
      enabled: true,
      pets: [
        { name: "Prisma Shard", tier: "Secret", type: "odds", value: 12500000 }
      ]
    }
  ];

  // ========= Helpers =========
  const fmtInt = (n) => Math.round(n).toLocaleString();
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  function luckMultiplierFromPercent(luckPercent){
    const lp = Number(luckPercent);
    if (!isFinite(lp) || lp < 0) return 1;
    return 1 + (lp/100);
  }

  function parseOddsInputToProb(s){
    if (!s) return null;
    let t = String(s).trim().toLowerCase().replace(/,/g,'');
    if (!t) return null;

    if (t.includes('/')) {
      const denom = Number(t.split('/')[1]);
      if (isFinite(denom) && denom > 0) return 1/denom;
      return null;
    }
    if (t.endsWith('%')) {
      const p = Number(t.slice(0,-1));
      if (isFinite(p) && p > 0) return p/100;
      return null;
    }
    const v = Number(t);
    if (isFinite(v) && v > 0 && v <= 1) return v;
    if (isFinite(v) && v > 1) return 1/v;
    return null;
  }

  function pctPretty(prob){
    const pct = prob * 100;
    if (!isFinite(pct)) return "N/A";
    if (pct >= 10) return `${pct.toFixed(2)}%`;
    if (pct >= 1) return `${pct.toFixed(3)}%`;
    if (pct >= 0.1) return `${pct.toFixed(4)}%`;
    if (pct >= 0.01) return `${pct.toFixed(5)}%`;
    return `${pct.toFixed(6)}%`;
  }

  function timePretty(sec){
    if (!isFinite(sec) || sec < 0) return "N/A";
    if (sec < 60) return `${sec.toFixed(2)}s`;
    const min = sec/60;
    if (min < 60) return `${min.toFixed(2)}m`;
    const hr = min/60;
    if (hr < 24) return `${hr.toFixed(2)}h`;
    const day = hr/24;
    return `${day.toFixed(2)}d`;
  }

  function tierAtLeast(tier, minTier){
    const order = ["Common","Rare","Epic","Legendary","Secret","Royal"];
    const a = order.indexOf(tier);
    const b = order.indexOf(minTier);
    if (a === -1 || b === -1) return false;
    return a >= b;
  }

  function passesTierFilter(tier, filter){
    if (!filter) return true;
    if (filter === "Legendary+") return tierAtLeast(tier, "Legendary");
    if (filter === "Epic+") return tierAtLeast(tier, "Epic");
    if (filter === "Secret+") return tierAtLeast(tier, "Secret");
    if (filter === "Royal") return tier === "Royal";
    if (filter === "Secret") return tier === "Secret";
    if (filter === "Legendary") return tier === "Legendary";
    if (filter === "Epic") return tier === "Epic";
    if (filter === "Rare") return tier === "Rare";
    if (filter === "Common") return tier === "Common";
    return true;
  }

  // --- NEW MODEL (fixes Prisma Shard / avoids normalization bugs) ---
  function buildEggModel(egg, luckMult){
    const percentPets = [];
    const oddsPets = [];

    for (const p of egg.pets){
      if (p.type === "percent"){
        const prob = clamp(p.value/100, 0, 1);
        percentPets.push({ ...p, prob });
      } else {
        const effDen = p.value / luckMult;
        const prob = clamp(1/effDen, 0, 1);
        oddsPets.push({ ...p, effDen, prob });
      }
    }

    const percentSum = percentPets.reduce((a,b)=>a + b.prob, 0);
    const leftover = clamp(1 - percentSum, 0, 1);

    // For selecting a normal (percent) result:
    // normalize within the percent group (only for picking WHICH percent pet, not changing their actual odds)
    const percentPick = percentPets.map(p => ({...p, pickW: percentSum>0 ? (p.prob/percentSum) : 0}));

    // Sort odds pets rarest-first (highest denom first) so if multiple hit, we count the rarest one.
    oddsPets.sort((a,b)=> (b.effDen ?? 0) - (a.effDen ?? 0));

    return { percentPets, percentSum, leftover, percentPick, oddsPets };
  }

  function pickFromWeights(items, wKey){
    const r = Math.random();
    let acc = 0;
    for (const it of items){
      acc += it[wKey];
      if (r <= acc) return it;
    }
    return items[items.length-1];
  }

  function rollOneHatch(model){
    // Step 1: roll the normal (percent) pet, or "Nothing" if leftover triggers or no percent pets.
    let normal = null;
    if (model.percentPets.length > 0 && model.percentSum > 0) {
      // If leftover exists, sometimes you get "Nothing" instead of a percent pet.
      if (Math.random() < model.leftover) {
        normal = null; // Nothing
      } else {
        normal = pickFromWeights(model.percentPick, "pickW");
      }
    }

    // Step 2: independent checks for odds pets (Legendary/Secret/Royal/Secret Bounty etc)
    // If any hit, return the rarest hit (by effDen).
    let hit = null;
    for (const p of model.oddsPets){
      if (Math.random() < p.prob) {
        hit = p; // because sorted rarest-first, the first hit is the rarest. keep it.
        break;
      }
    }

    return hit || normal; // if odds hit, override; else normal (or null)
  }

  // ========= UI =========
  const el = (id) => document.getElementById(id);

  document.addEventListener("DOMContentLoaded", () => {
    const tabs = document.querySelectorAll(".tab");
    tabs.forEach(t => t.addEventListener("click", () => {
      tabs.forEach(x => x.classList.remove("active"));
      t.classList.add("active");
      const tab = t.dataset.tab;
      el("single").style.display = tab === "single" ? "" : "none";
      el("eggs").style.display = tab === "eggs" ? "" : "none";
      el("sim").style.display = tab === "sim" ? "" : "none";
    }));

    const enabledEggs = EGGS.filter(e => e.enabled);
    const eggSelect = el("eggSelect");
    const simEggSelect = el("simEggSelect");

    for (const e of enabledEggs){
      const o1 = document.createElement("option");
      o1.value = e.name;
      o1.textContent = e.name;
      eggSelect.appendChild(o1);

      const o2 = document.createElement("option");
      o2.value = e.name;
      o2.textContent = e.name;
      simEggSelect.appendChild(o2);
    }

    // Single pet dropdown
    const allPets = [];
    for (const egg of enabledEggs){
      for (const p of egg.pets){
        allPets.push({ egg: egg.name, cost: egg.cost, currency: egg.currency, ...p });
      }
    }
    const singlePetSelect = el("singlePetSelect");
    allPets.forEach((p, idx) => {
      const opt = document.createElement("option");
      opt.value = String(idx);
      opt.textContent = `${p.name} (${p.egg})`;
      singlePetSelect.appendChild(opt);
    });

    // Sim stop pet dropdown
    const simStopPet = el("simStopPet");
    function refreshSimStopPet(){
      const eggName = simEggSelect.value;
      const egg = enabledEggs.find(e => e.name === eggName);
      simStopPet.innerHTML = `<option value="">No early stop</option>`;
      if (!egg) return;
      egg.pets.forEach(p => {
        const o = document.createElement("option");
        o.value = p.name;
        o.textContent = `${p.name} (${p.tier})`;
        simStopPet.appendChild(o);
      });
    }
    simEggSelect.addEventListener("change", refreshSimStopPet);
    refreshSimStopPet();

    // Luck multiplier live
    const updateLuckText = () => {
      const mul = luckMultiplierFromPercent(el("luckPercent").value);
      el("luckMulText").textContent = `Multiplier: ${mul.toFixed(2)}√ó`;
    };
    el("luckPercent").addEventListener("input", updateLuckText);
    updateLuckText();

    // Meta updates
    const updateSingleMeta = () => {
      const idx = Number(singlePetSelect.value);
      const p = allPets[idx];
      if (!p) { el("singlePetMeta").textContent = ""; return; }
      const baseStr = p.type === "percent" ? `${p.value}%` : `1/${p.value.toLocaleString()}`;
      el("singlePetMeta").innerHTML =
        `Egg: <b>${p.egg}</b> ‚Ä¢ Tier: <span class="tier ${p.tier}">${p.tier}</span> ‚Ä¢ Base: <b>${baseStr}</b>`;
    };
    singlePetSelect.addEventListener("change", updateSingleMeta);
    updateSingleMeta();

    const updateEggMeta = () => {
      const egg = enabledEggs.find(e => e.name === eggSelect.value);
      if (!egg) { el("eggMeta").textContent = ""; return; }
      const costStr = egg.currency === "coins" ? `${egg.cost.toLocaleString()} coins`
                    : egg.currency === "hearts" ? `${egg.cost.toLocaleString()} hearts`
                    : egg.currency;
      el("eggMeta").textContent = `Cost: ${costStr}`;
    };
    eggSelect.addEventListener("change", updateEggMeta);
    updateEggMeta();

    // ===== Single calc (same as your simplified version) =====
    el("calcSingleBtn").addEventListener("click", () => {
      const luckMult = luckMultiplierFromPercent(el("luckPercent").value);
      const hatchTime = Number(el("hatchTimeSec").value);
      const eggsPer = Math.max(1, Math.floor(Number(el("eggsPerCycle").value || 1)));
      const shinyMult = Math.max(1, Number(el("shinyMult").value || 100));

      const overrideProb = parseOddsInputToProb(el("baseOddsInput").value);

      const calcBatchStats = (perEggProb) => {
        const perBatchChance = 1 - Math.pow(1 - perEggProb, eggsPer);
        const avgBatches = perBatchChance > 0 ? (1 / perBatchChance) : Infinity;
        const avgTime = avgBatches * hatchTime;
        return { perBatchChance, avgBatches, avgTime };
      };

      if (overrideProb) {
        const approxDen = 1 / overrideProb;
        const effDen = approxDen / luckMult;
        const perEggProb = 1 / effDen;
        const s = calcBatchStats(perEggProb);

        let out =
`Custom Odds
Effective Odds: 1/${fmtInt(effDen)}
Chance per batch: ${pctPretty(s.perBatchChance)}
Avg batches: ~${isFinite(s.avgBatches) ? fmtInt(s.avgBatches) : "‚àû"}
Avg time: ~${timePretty(s.avgTime)}
`;

        if (el("wantShiny").value === "yes") {
          const effDenShiny = effDen * shinyMult;
          const shinyStats = calcBatchStats(1/effDenShiny);
          out +=
`\nShiny (√ó${shinyMult})
Shiny Odds: 1/${fmtInt(effDenShiny)}
Shiny chance per batch: ${pctPretty(shinyStats.perBatchChance)}
Avg shiny batches: ~${isFinite(shinyStats.avgBatches) ? fmtInt(shinyStats.avgBatches) : "‚àû"}
Avg shiny time: ~${timePretty(shinyStats.avgTime)}
`;
        }

        el("singleOut").textContent = out;
        return;
      }

      const idx = Number(singlePetSelect.value);
      const p = allPets[idx];
      if (!p) { el("singleOut").textContent = "Pick a pet first."; return; }

      if (p.type === "percent") {
        const s = calcBatchStats(p.value/100);
        let out =
`${p.name} [${p.tier}]
Egg: ${p.egg}
Odds: ${p.value}%

Chance per batch: ${pctPretty(s.perBatchChance)}
Avg batches: ~${isFinite(s.avgBatches) ? fmtInt(s.avgBatches) : "‚àû"}
Avg time: ~${timePretty(s.avgTime)}
`;
        if (el("wantShiny").value === "yes") {
          const shinyStats = calcBatchStats((p.value/100)/shinyMult);
          out +=
`\nShiny (√ó${shinyMult})
Shiny chance per batch: ${pctPretty(shinyStats.perBatchChance)}
Avg shiny batches: ~${isFinite(shinyStats.avgBatches) ? fmtInt(shinyStats.avgBatches) : "‚àû"}
Avg shiny time: ~${timePretty(shinyStats.avgTime)}
`;
        }
        el("singleOut").textContent = out;
        return;
      }

      const effDen = p.value / luckMult;
      const s = calcBatchStats(1/effDen);

      let out =
`${p.name} [${p.tier}]
Egg: ${p.egg}
Base Odds: 1/${fmtInt(p.value)}
Effective Odds: 1/${fmtInt(effDen)}

Chance per batch: ${pctPretty(s.perBatchChance)}
Avg batches: ~${isFinite(s.avgBatches) ? fmtInt(s.avgBatches) : "‚àû"}
Avg time: ~${timePretty(s.avgTime)}
`;

      if (el("wantShiny").value === "yes") {
        const effDenShiny = effDen * shinyMult;
        const shinyStats = calcBatchStats(1/effDenShiny);
        out +=
`\nShiny (√ó${shinyMult})
Shiny Odds: 1/${fmtInt(effDenShiny)}
Shiny chance per batch: ${pctPretty(shinyStats.perBatchChance)}
Avg shiny batches: ~${isFinite(shinyStats.avgBatches) ? fmtInt(shinyStats.avgBatches) : "‚àû"}
Avg shiny time: ~${timePretty(shinyStats.avgTime)}
`;
      }

      el("singleOut").textContent = out;
    });

    el("copySingleBtn").addEventListener("click", () => {
      navigator.clipboard.writeText(el("singleOut").textContent || "");
    });

    // ===== Egg Odds (no normalization; Prisma Shard now correct) =====
    el("renderEggBtn").addEventListener("click", () => {
      const luckMult = luckMultiplierFromPercent(el("luckPercent").value);
      const eggsPer = Math.max(1, Math.floor(Number(el("eggsPerCycle").value || 1)));
      const hatchTime = Number(el("hatchTimeSec").value);

      const egg = enabledEggs.find(e => e.name === eggSelect.value);
      if (!egg) { el("eggOut").textContent = "Select an egg."; return; }

      const filter = el("tierFilter").value || "Legendary+";
      const model = buildEggModel(egg, luckMult);

      const perBatchChance = (perEggProb) => 1 - Math.pow(1 - perEggProb, eggsPer);

      let lines = [];
      lines.push(`${egg.name} ‚Äî Cost: ${egg.cost.toLocaleString()} ${egg.currency}`);
      lines.push(`Luck: ${Number(el("luckPercent").value||0).toLocaleString()}% (${luckMult.toFixed(2)}√ó) ‚Ä¢ Eggs per batch: ${eggsPer} ‚Ä¢ Hatch time: ${hatchTime}s`);
      lines.push(`Showing: ${filter}`);
      lines.push("");

      const shown = [];

      // Show percent pets
      for (const p of model.percentPets){
        if (!passesTierFilter(p.tier, filter)) continue;
        const pb = perBatchChance(p.prob);
        const avgB = pb > 0 ? 1/pb : Infinity;
        shown.push({
          name: p.name, tier: p.tier,
          oddsLine: `Odds: ${p.value}%`,
          pb, avgB, avgT: avgB*hatchTime,
          sortKey: tierAtLeast(p.tier,"Legendary") ? 1 : 0
        });
      }

      // Show odds pets
      for (const p of model.oddsPets){
        if (!passesTierFilter(p.tier, filter)) continue;
        const pb = perBatchChance(p.prob);
        const avgB = pb > 0 ? 1/pb : Infinity;
        shown.push({
          name: p.name, tier: p.tier,
          oddsLine: `Odds: 1/${fmtInt(p.effDen)} (effective)`,
          pb, avgB, avgT: avgB*hatchTime,
          sortKey: 10 + (p.effDen||0) // keep rares grouped
        });
      }

      if (shown.length === 0) {
        lines.push("No pets match that filter.");
        el("eggOut").textContent = lines.join("\n");
        return;
      }

      // Sort: Royals/Secrets/Legends first by rarity-ish
      shown.sort((a,b)=> (b.sortKey - a.sortKey));

      for (const p of shown){
        lines.push(`${p.name}  [${p.tier}]`);
        lines.push(`  ${p.oddsLine}`);
        lines.push(`  Chance per batch: ${pctPretty(p.pb)}`);
        lines.push(`  Avg batches: ~${isFinite(p.avgB) ? fmtInt(p.avgB) : "‚àû"} ‚Ä¢ Avg time: ~${timePretty(p.avgT)}`);
        lines.push("");
      }

      // If egg has ‚Äúleftover‚Äù chance (like Secret Bounty), mention it
      if (model.percentPets.length === 0 && model.oddsPets.length > 0) {
        lines.push(`Note: This egg can also roll "Nothing" most of the time.`);
      } else if (model.leftover > 0.000001) {
        lines.push(`Note: There is also a ${pctPretty(model.leftover)} chance per hatch of "Nothing / other".`);
      }

      el("eggOut").textContent = lines.join("\n").trim();
    });

    el("copyEggBtn").addEventListener("click", () => {
      navigator.clipboard.writeText(el("eggOut").textContent || "");
    });

    // ===== Simulator (Prisma Shard fixed) =====
    el("simBtn").addEventListener("click", () => {
      const luckMult = luckMultiplierFromPercent(el("luckPercent").value);
      const eggsPer = Math.max(1, Math.floor(Number(el("eggsPerCycle").value || 1)));
      const hatchTime = Number(el("hatchTimeSec").value);
      const shinyMult = Math.max(1, Number(el("shinyMult").value || 100));

      const egg = enabledEggs.find(e => e.name === simEggSelect.value);
      if (!egg) { el("simOut").textContent = "Select an egg."; return; }

      const batchesRequested = Math.max(1, Math.floor(Number(el("simCycles").value || 1)));
      const stopPet = el("simStopPet").value || "";
      const stopMode = el("simStopMode").value;

      const model = buildEggModel(egg, luckMult);

      // counts (only real pets, not "Nothing")
      const counts = {};
      for (const p of egg.pets) counts[p.name] = 0;
      let nothingCount = 0;

      let batchesDone = 0;
      let stopHit = false;
      let stopAtBatch = null;

      for (let b = 0; b < batchesRequested; b++){
        batchesDone++;
        for (let r = 0; r < eggsPer; r++){
          const pet = rollOneHatch(model);
          if (!pet) {
            nothingCount++;
          } else {
            counts[pet.name] = (counts[pet.name] || 0) + 1;
          }

          if (stopPet && pet && pet.name === stopPet) {
            if (stopMode === "any") {
              stopHit = true;
              stopAtBatch = batchesDone;
              break;
            } else {
              // shiny: chance of shiny = 1 / shinyMult (your rule)
              // if you later want to use the game's debug shiny odds (1/66), we can replace this.
              const shinyChance = clamp(1 / shinyMult, 0, 1);
              if (Math.random() < shinyChance) {
                stopHit = true;
                stopAtBatch = batchesDone;
                break;
              }
            }
          }
        }
        if (stopHit) break;
      }

      const totalEggs = batchesDone * eggsPer;
      const totalTime = batchesDone * hatchTime;

      const lines = [];
      lines.push(`Simulation ‚Äî ${egg.name}`);
      lines.push(`Luck: ${Number(el("luckPercent").value||0).toLocaleString()}% (${luckMult.toFixed(2)}√ó)`);
      lines.push(`Eggs per batch: ${eggsPer} ‚Ä¢ Hatch time: ${hatchTime}s`);
      lines.push(`Batches simulated: ${batchesDone.toLocaleString()} (requested ${batchesRequested.toLocaleString()})`);
      lines.push(`Total eggs opened: ${totalEggs.toLocaleString()} ‚Ä¢ Simulated time: ${timePretty(totalTime)}`);
      if (stopPet) {
        lines.push(`Stop target: ${stopPet} (${stopMode === "shiny" ? "shiny" : "any"})`);
        lines.push(stopHit ? `‚úÖ Hit at batch ${stopAtBatch}` : `‚ùå Not hit`);
      }
      lines.push("");
      if (nothingCount > 0) lines.push(`Nothing/Other: ${nothingCount.toLocaleString()}`);
      lines.push("Counts:");

      Object.entries(counts)
        .sort((a,b)=>b[1]-a[1])
        .forEach(([name, ct]) => lines.push(`  ${name}: ${ct.toLocaleString()}`));

      el("simOut").textContent = lines.join("\n");
    });

    el("copySimBtn").addEventListener("click", () => {
      navigator.clipboard.writeText(el("simOut").textContent || "");
    });
  });
})();
</script>
</body>
</html>
